# Copyright (c) Microsoft. All rights reserved.

import logging
from typing import TYPE_CHECKING, List, Optional

from pydantic import PrivateAttr

from semantic_kernel.prompt_template.input_variable import InputVariable
from semantic_kernel.prompt_template.prompt_template_base import PromptTemplateBase
from semantic_kernel.prompt_template.prompt_template_config import PromptTemplateConfig
from semantic_kernel.template_engine.blocks.block import Block
from semantic_kernel.template_engine.blocks.block_types import BlockTypes
from semantic_kernel.template_engine.protocols.text_renderer import TextRenderer
from semantic_kernel.template_engine.template_tokenizer import TemplateTokenizer

if TYPE_CHECKING:
    from semantic_kernel.functions.kernel_arguments import KernelArguments
    from semantic_kernel.kernel import Kernel

logger: logging.Logger = logging.getLogger(__name__)


class KernelPromptTemplate(PromptTemplateBase):
    _tokenizer: TemplateTokenizer = PrivateAttr()
    _blocks: List[Block] = PrivateAttr()

    def __init__(self, prompt_config: PromptTemplateConfig):
        super().__init__()
        self._tokenizer = TemplateTokenizer()
        self._blocks = self.extract_blocks(prompt_config)
        self._add_missing_input_variables(self._blocks, prompt_config)

    def _add_missing_input_variables(self, blocks, config):
        # Add all of the existing input variables to our known set. We'll avoid adding any
        # dynamically discovered input variables with the same name.
        seen = {iv.name.lower() for iv in config.input_variables}

        def add_if_missing(variable_name):
            # Convert variable_name to lower case to handle case-insensitivity
            if variable_name and variable_name.lower() not in seen:
                seen.add(variable_name.lower())
                config.input_variables.append(InputVariable(name=variable_name))

        # Enumerate every block in the template, adding any variables that are referenced.
        for block in blocks:
            if block.type == BlockTypes.VARIABLE:
                # Add all variables from variable blocks, e.g. "{{$a}}".
                add_if_missing(block.name)
            elif block.type == BlockTypes.CODE:
                for code_block in block.tokens:
                    if code_block.type == BlockTypes.VARIABLE:
                        # Add all variables from code blocks, e.g. "{{p.bar $b}}".
                        add_if_missing(code_block.name)
                    elif code_block.type == BlockTypes.NAMED_ARG and getattr(code_block, "var_block", None):
                        # Add all variables from named arguments, e.g. "{{p.bar b = $b}}".
                        # represents a named argument for a function call.
                        # For example, in the template {{ MyPlugin.MyFunction var1="foo" }}, var1="foo"
                        # is a named arg block.
                        # TODO HANDLE THIS
                        add_if_missing(code_block.var_block.name)

    def extract_blocks(self, config: PromptTemplateConfig, validate: bool = True) -> List[Block]:
        """
        Given a prompt template string, extract all the blocks
        (text, variables, function calls).

        """
        template_text = config.template
        logger.debug(f"Extracting blocks from template: {template_text}")
        blocks = self._tokenizer.tokenize(template_text)

        if validate:
            for block in blocks:
                is_valid, error_message = block.is_valid()
                if not is_valid:
                    raise ValueError(error_message)

        return blocks

    async def render(self, kernel: "Kernel", arguments: Optional["KernelArguments"] = None) -> str:
        """
        Using the prompt template, replace the variables with their values
        and execute the functions replacing their reference with the
        function result.

        Args:
            kernel: The kernel instance
            arguments: The kernel arguments

        Returns:
            The prompt template ready to be used for an AI request
        """
        return await self.render_blocks(self._blocks, kernel, arguments)

    async def render_blocks(self, blocks: List[Block], kernel: "Kernel", arguments: "KernelArguments") -> str:
        """
        Given a list of blocks render each block and compose the final result.

        :param blocks: Template blocks generated by ExtractBlocks
        :param context: Access into the current kernel execution context
        :return: The prompt template ready to be used for an AI request
        """
        from semantic_kernel.template_engine.protocols.code_renderer import CodeRenderer

        logger.debug(f"Rendering list of {len(blocks)} blocks")
        rendered_blocks = []
        for block in blocks:
            if isinstance(block, TextRenderer):
                rendered_blocks.append(block.render(kernel, arguments))
            elif isinstance(block, CodeRenderer):
                rendered_blocks.append(await block.render_code(kernel, arguments))
            else:
                error = "unexpected block type, the block doesn't have a rendering " "protocol assigned to it"
                logger.error(error)
                raise ValueError(error)

        logger.debug(f"Rendered prompt: {''.join(rendered_blocks)}")
        return "".join(rendered_blocks)

    def render_variables(
        self, blocks: List[Block], kernel: "Kernel", arguments: Optional["KernelArguments"] = None
    ) -> List[Block]:
        """
        Given a list of blocks, render the Variable Blocks, replacing
        placeholders with the actual value in memory.

        :param blocks: List of blocks, typically all the blocks found in a template
        :param variables: Container of all the temporary variables known to the kernel
        :return: An updated list of blocks where Variable Blocks have rendered to
            Text Blocks
        """
        from semantic_kernel.template_engine.blocks.text_block import TextBlock

        logger.debug("Rendering variables")

        rendered_blocks = []
        for block in blocks:
            if block.type != BlockTypes.VARIABLE:
                rendered_blocks.append(block)
                continue
            if not isinstance(block, TextRenderer):
                raise ValueError("TextBlock must implement TextRenderer protocol")
            rendered_blocks.append(TextBlock.from_text(block.render(kernel, arguments)))

        return rendered_blocks

    async def render_code(self, blocks: List[Block], kernel: "Kernel", arguments: "KernelArguments") -> List[Block]:
        """
        Given a list of blocks, render the Code Blocks, executing the
        functions and replacing placeholders with the functions result.

        :param blocks: List of blocks, typically all the blocks found in a template
        :param execution_context: Access into the current kernel execution context
        :return: An updated list of blocks where Code Blocks have rendered to
            Text Blocks
        """
        from semantic_kernel.template_engine.blocks.text_block import TextBlock
        from semantic_kernel.template_engine.protocols.code_renderer import CodeRenderer

        logger.debug("Rendering code")

        rendered_blocks = []
        for block in blocks:
            if block.type != BlockTypes.CODE:
                rendered_blocks.append(block)
                continue
            if not isinstance(block, CodeRenderer):
                raise ValueError("CodeBlock must implement CodeRenderer protocol")
            rendered_blocks.append(TextBlock.from_text(await block.render_code(kernel, arguments)))

        return rendered_blocks
