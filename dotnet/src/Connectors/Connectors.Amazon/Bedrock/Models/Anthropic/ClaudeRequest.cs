// Copyright (c) Microsoft. All rights reserved.

using System.Text.Json.Serialization;
using Amazon.BedrockRuntime.Model;
using Amazon.Runtime.Documents;
using Connectors.Amazon.Core.Requests;

namespace Connectors.Amazon.Models.Anthropic;

/// <summary>
/// Anthropic Claude request object.
/// </summary>
public static class ClaudeRequest
{
    /// <summary>
    /// Claude chat completion object as needed for Converse Bedrock call.
    /// </summary>
    public class ClaudeChatCompletionRequest : IChatCompletionRequest
    {
        /// <inheritdoc />
        public List<Message>? Messages { get; set; }
        /// <inheritdoc />
        public List<SystemContentBlock>? System { get; set; }
        /// <inheritdoc />
        public InferenceConfiguration? InferenceConfig { get; set; }
        /// <inheritdoc />
        public Document AdditionalModelRequestFields { get; set; }
        /// <inheritdoc />
        public List<string>? AdditionalModelResponseFieldPaths { get; set; }
        /// <inheritdoc />
        public GuardrailConfiguration? GuardrailConfig { get; set; }
        /// <inheritdoc />
        public string? ModelId { get; set; }
        /// <inheritdoc />
        public ToolConfiguration? ToolConfig { get; set; }
        /// <summary>
        /// The anthropic version. The value must be bedrock-2023-05-31.
        /// </summary>
        public string? AnthropicVersion { get; set; }
        /// <summary>
        /// Definitions of tools that the model may use. If you include tools in your request, the model may return tool_use content blocks that represent the model's use of those tools. You can then run those tools using the tool input generated by the model and then optionally return results back to the model using tool_result content blocks.
        /// </summary>
        public List<ClaudeTool>? Tools { get; set; }
        /// <summary>
        /// Specifices how the model should use the provided tools. The model can use a specific tool, any available tool, or decide by itself.
        /// </summary>
        public ClaudeToolChoice? ToolChoice { get; set; }
        /// <summary>
        /// (Optional) Definitions of tools that the model may use.
        /// </summary>
        public class ClaudeTool : Tool
        {
            /// <summary>
            /// The name of the tool.
            /// </summary>
            public required string Name { get; set; }
            /// <summary>
            /// (optional, but strongly recommended) The description of the tool.
            /// </summary>
            public string? Description { get; set; }
            /// <summary>
            /// The JSON schema for the tool.
            /// </summary>
            public required string InputSchema { get; set; }
        }
        /// <summary>
        /// (Optional) Specifices how the model should use the provided tools. The model can use a specific tool, any available tool, or decide by itself.
        /// </summary>
        public class ClaudeToolChoice
        {
            /// <summary>
            /// The type of tool choice. Possible values are any (use any available tool), auto (the model decides), and tool (use the specified tool).
            /// </summary>
            public string Type { get; set; }
            /// <summary>
            /// (Optional) The name of the tool to use. Required if you specify tool in the type field.
            /// </summary>
            public string? Name { get; set; }
        }
    }
    /// <summary>
    /// The Anthropic Claude text generation object to be put into the invoke model request body.
    /// </summary>
    public sealed class ClaudeTextGenerationRequest : ITextGenerationRequest
    {
        /// <summary>
        /// (Required) The prompt that you want Claude to complete. For proper response generation you need to format your prompt using alternating \n\nHuman: and \n\nAssistant: conversational turns.
        /// </summary>
        [JsonPropertyName("prompt")]
        public required string Prompt { get; set; }
        /// <summary>
        /// (Required) The maximum number of tokens to generate before stopping. We recommend a limit of 4,000 tokens for optimal performance.
        /// </summary>
        [JsonPropertyName("max_tokens_to_sample")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public int? MaxTokensToSample { get; set; }
        /// <summary>
        /// (Optional) Sequences that will cause the model to stop generating. Anthropic Claude models stop on "\n\nHuman:", and may include additional built-in stop sequences in the future.Use the stop_sequences inference parameter to include additional strings that will signal the model to stop generating text.
        /// </summary>
        [JsonPropertyName("stop_sequences")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public IList<string>? StopSequences { get; set; }
        /// <summary>
        /// (Optional) The amount of randomness injected into the response. Use a value closer to 0 for analytical / multiple choice, and a value closer to 1 for creative and generative tasks.
        /// </summary>
        [JsonPropertyName("temperature")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public double? Temperature { get; set; }
        /// <summary>
        /// (Optional) Use nucleus sampling. In nucleus sampling, Anthropic Claude computes the cumulative distribution over all the options for each subsequent token in decreasing probability order and cuts it off once it reaches a particular probability specified by top_p.You should alter either temperature or top_p, but not both.
        /// </summary>
        [JsonPropertyName("top_p")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public double? TopP { get; set; }
        /// <summary>
        /// (Optional) Only sample from the top K options for each subsequent token. Use top_k to remove long tail low probability responses.
        /// </summary>
        [JsonPropertyName("top_k")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]
        public int? TopK { get; set; }

        string ITextGenerationRequest.InputText => this.Prompt;

        double? ITextGenerationRequest.TopP => this.TopP;

        double? ITextGenerationRequest.Temperature => this.Temperature;

        int? ITextGenerationRequest.MaxTokens => this.MaxTokensToSample;

        IList<string>? ITextGenerationRequest.StopSequences => this.StopSequences;
    }
}
